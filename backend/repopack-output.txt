This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-04-03T06:12:31.526Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
prisma/
  schema.prisma
src/
  conversions/
    dto/
      create-conversion.dto.ts
    conversions.controller.ts
    conversions.module.ts
    conversions.service.ts
  pdf/
    pdf.module.ts
    pdf.service.ts
  prisma/
    prisma.module.ts
    prisma.service.ts
  shared/
    decorators/
      user.decorator.ts
    guards/
      clerk.guard.ts
    interceptors/
      sentry.interceptor.ts
  users/
    users.controller.ts
    users.module.ts
    users.service.ts
  xml/
    xml.module.ts
    xml.service.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  instrument.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.env.example
.gitignore
.prettierrc
eslint.config.mjs
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id
  email         String       @unique
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  conversions   Conversion[]
}

model Conversion {
  id            String   @id @default(cuid())
  userId        String
  originalName  String
  fileUrl       String
  xmlOutput     String?
  status        String   @default("pending") // pending, processing, completed, failed
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

================
File: src/conversions/dto/create-conversion.dto.ts
================
import { IsString, IsNotEmpty, IsUrl } from 'class-validator';

export class CreateConversionDto {
  @IsString()
  @IsNotEmpty()
  originalName: string;

  @IsString()
  @IsNotEmpty()
  @IsUrl()
  fileUrl: string;
}

================
File: src/conversions/conversions.controller.ts
================
import {
    Controller,
    Get,
    Post,
    Param,
    Body,
    UseGuards,
    NotFoundException,
    BadRequestException,
  } from '@nestjs/common';
  import { ConversionsService } from './conversions.service';
  import { Conversion } from '@prisma/client';
  import { ClerkGuard } from '../shared/guards/clerk.guard';
  import { GetUser } from '../shared/decorators/user.decorator';
  import { CreateConversionDto } from './dto/create-conversion.dto';
  
  @Controller('conversions')
  @UseGuards(ClerkGuard)
  export class ConversionsController {
    constructor(private readonly conversionsService: ConversionsService) {}
  
    @Post()
    async create(
      @GetUser('id') userId: string,
      @Body() createConversionDto: CreateConversionDto,
    ): Promise<Conversion> {
      const { originalName, fileUrl } = createConversionDto;
      
      // Create conversion record
      const conversion = await this.conversionsService.create(
        userId,
        originalName,
        fileUrl,
      );
      
      // Start processing in background
      this.conversionsService.processConversion(conversion.id).catch((error) => {
        console.error('Error processing conversion:', error);
      });
      
      return conversion;
    }
  
    @Get()
    async findAll(@GetUser('id') userId: string): Promise<Conversion[]> {
      return this.conversionsService.findAll(userId);
    }
  
    @Get(':id')
    async findOne(
      @Param('id') id: string,
      @GetUser('id') userId: string,
    ): Promise<Conversion> {
      const conversion = await this.conversionsService.findOne(id, userId);
      
      if (!conversion) {
        throw new NotFoundException('Conversion not found');
      }
      
      return conversion;
    }
  }

================
File: src/conversions/conversions.module.ts
================
import { Module } from '@nestjs/common';
import { ConversionsService } from './conversions.service';
import { ConversionsController } from './conversions.controller';
import { PdfModule } from '../pdf/pdf.module';
import { XmlModule } from '../xml/xml.module';
import { UsersModule } from '../users/users.module'; 
import { ClerkGuard } from '../shared/guards/clerk.guard'; 

@Module({
  imports: [PdfModule, XmlModule, UsersModule], 
  controllers: [ConversionsController],
  providers: [ConversionsService, ClerkGuard],
  exports: [ConversionsService, ClerkGuard], 
})
export class ConversionsModule {}

================
File: src/conversions/conversions.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Conversion } from '@prisma//client';
import { PdfService } from '../pdf//pdf.service';
import { XmlService } from '../xml//xml.service';

@Injectable()
export class ConversionsService {
  constructor(
    private prisma: PrismaService,
    private pdfService: PdfService,
    private xmlService: XmlService,
  ) {}

  async create(
    userId: string,
    originalName: string,
    fileUrl: string,
  ): Promise<Conversion> {
    return this.prisma.conversion.create({
      data: {
        userId,
        originalName,
        fileUrl,
      },
    });
  }

  async findAll(userId: string): Promise<Conversion[]> {
    return this.prisma.conversion.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });
  }

  async findOne(id: string, userId: string): Promise<Conversion | null> {
    return this.prisma.conversion.findFirst({
      where: {
        id,
        userId,
      },
    });
  }

  async processConversion(id: string): Promise<Conversion> {
    // Update status to processing
    await this.prisma.conversion.update({
      where: { id },
      data: { status: 'processing' },
    });

    try {
      // Get conversion
      const conversion = await this.prisma.conversion.findUnique({
        where: { id },
      });

      if (!conversion) {
        throw new Error('Conversion not found');
      }

      // Extract text from PDF
      const pdfText = await this.pdfService.extractText(conversion.fileUrl);
      
      // Convert text to XML
      const xmlOutput = this.xmlService.generateXml(pdfText);

      // Update conversion with XML output
      return this.prisma.conversion.update({
        where: { id },
        data: {
          xmlOutput,
          status: 'completed',
        },
      });
    } catch (error) {
      // Update status to failed
      return this.prisma.conversion.update({
        where: { id },
        data: { status: 'failed' },
      });
    }
  }
}

================
File: src/pdf/pdf.module.ts
================
import { Module } from '@nestjs/common';
import { PdfService } from './/pdf.service';

@Module({
  providers: [PdfService],
  exports: [PdfService],
})
export class PdfModule {}

================
File: src/pdf/pdf.service.ts
================
import { Injectable } from '@nestjs/common';
import * as pdfParse from 'pdf-parse';
import * as https from 'https';
import * as http from 'http';

@Injectable()
export class PdfService {
  async extractText(pdfUrl: string): Promise<string> {
    try {
      // Download PDF from URL
      const pdfBuffer = await this.downloadFile(pdfUrl);
      
      // Extract text from PDF
      const data = await pdfParse(pdfBuffer);
      
      return data.text;
    } catch (error) {
      console.error('Error extracting text from PDF:', error);
      throw new Error('Failed to extract text from PDF');
    }
  }

  private async downloadFile(url: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const client = url.startsWith('https') ? https : http;
      
      client.get(url, (response) => {
        // Handle redirects
        if (response.statusCode === 301 || response.statusCode === 302) {
          if (response.headers.location) {
            return this.downloadFile(response.headers.location)
              .then(resolve)
              .catch(reject);
          } else {
            return reject(new Error('Redirect location is undefined'));
          }
        }
        
        if (response.statusCode !== 200) {
          return reject(new Error(`Failed to download file: ${response.statusCode}`));
        }
        
        const chunks: Buffer[] = [];
        
        response.on('data', (chunk) => {
          chunks.push(chunk);
        });
        
        response.on('end', () => {
          resolve(Buffer.concat(chunks));
        });
      }).on('error', reject);
    });
  }
}

================
File: src/prisma/prisma.module.ts
================
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

================
File: src/prisma/prisma.service.ts
================
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    super({
      log: ['error', 'warn'],
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

================
File: src/shared/decorators/user.decorator.ts
================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const GetUser = createParamDecorator(
  (data: string | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    return data ? user?.[data] : user;
  },
);

================
File: src/shared/guards/clerk.guard.ts
================
// backend/src/shared/guards/clerk.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { clerkClient } from '@clerk/clerk-sdk-node';
import { UsersService } from '../../users/users.service';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class ClerkGuard implements CanActivate {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
  ) {
    // Make sure CLERK_SECRET_KEY is set
    const secretKey = this.configService.get<string>('CLERK_SECRET_KEY');
    if (!secretKey) {
      throw new Error('CLERK_SECRET_KEY is not defined');
    }
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    
    try {
      // Get authorization header
      const authHeader = request.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        throw new UnauthorizedException('Invalid token');
      }

      // Extract token
      const token = authHeader.split(' ')[1];
      if (!token) {
        throw new UnauthorizedException('Missing token');
      }

      // Decode token to get user ID - this doesn't verify the token
      // We're relying on Clerk's API to verify the user exists
      const decodedToken = jwt.decode(token) as { sub?: string };
      if (!decodedToken || !decodedToken.sub) {
        throw new UnauthorizedException('Invalid token format');
      }

      const userId = decodedToken.sub;
      
      // Verify the user exists in Clerk
      try {
        const clerkUser = await clerkClient.users.getUser(userId);
        if (!clerkUser) {
          throw new UnauthorizedException('User not found');
        }
        
        // Get or create user in our database
        let user = await this.usersService.findOne(userId);
        
        if (!user) {
          // Find primary email
          const primaryEmail = clerkUser.emailAddresses.find(
            email => email.id === clerkUser.primaryEmailAddressId
          );
          
          if (!primaryEmail) {
            throw new UnauthorizedException('User has no primary email');
          }
          
          // Create user in our database
          user = await this.usersService.createUser({
            id: userId,
            email: primaryEmail.emailAddress,
          });
        }
        
        // Attach user to request
        request.user = {
          id: user?.id,
          email: user?.email,
        };
        
        return true;
      } catch (error) {
        if (error instanceof UnauthorizedException) {
          throw error;
        }
        console.error('Error verifying user with Clerk:', error);
        throw new UnauthorizedException('Failed to verify user');
      }
    } catch (error) {
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      console.error('Authentication error:', error);
      throw new UnauthorizedException('Authentication failed');
    }
  }
}

================
File: src/shared/interceptors/sentry.interceptor.ts
================
import {
    Injectable,
    NestInterceptor,
    ExecutionContext,
    CallHandler,
  } from '@nestjs/common';
  import { Observable } from 'rxjs';
  import { tap } from 'rxjs/operators';
  import * as Sentry from '@sentry/node';
  
  @Injectable()
  export class SentryInterceptor implements NestInterceptor {
    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
      return next.handle().pipe(
        tap(null, (exception) => {
          Sentry.captureException(exception);
        }),
      );
    }
  }

================
File: src/users/users.controller.ts
================
import { Controller, Get, UseGuards } from '@nestjs/common';
import { UsersService } from './users.service';
import { PrismaClient } from '@prisma/client';
import { ClerkGuard } from '../shared/guards/clerk.guard';
import { GetUser } from '../shared/decorators/user.decorator';

const prisma = new PrismaClient();
type User = Awaited<ReturnType<typeof prisma.user.findUnique>>;

@Controller('users')
@UseGuards(ClerkGuard)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get('me')
  async getMe(@GetUser() user: { id: string }): Promise<User> {
    return this.usersService.findOne(user.id);
  }
}

================
File: src/users/users.module.ts
================
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

================
File: src/users/users.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();
type User = Awaited<ReturnType<typeof prisma.user.findUnique>>;


@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async findOne(id: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
    });
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { email },
    });
  }

  async createUser(data: Prisma.UserCreateInput): Promise<User> {
    return this.prisma.user.create({
      data,
    });
  }

  async updateUser(id: string, data: Prisma.UserUpdateInput): Promise<User> {
    return this.prisma.user.update({
      where: { id },
      data,
    });
  }
}

================
File: src/xml/xml.module.ts
================
import { Module } from '@nestjs/common';
import { XmlService } from './/xml.service';

@Module({
  providers: [XmlService],
  exports: [XmlService],
})
export class XmlModule {}

================
File: src/xml/xml.service.ts
================
import { Injectable } from '@nestjs/common';
import * as xml2js from 'xml2js';

@Injectable()
export class XmlService {
  generateXml(text: string): string {
    try {
      // Split text into paragraphs
      const paragraphs = text
        .split('\n\n')
        .map((p) => p.trim())
        .filter((p) => p);
      
      // Create XML structure
      const xmlObj = {
        document: {
          $: { version: '1.0' },
          section: [
            {
              paragraph: paragraphs.map((p) => ({
                text: p,
              })),
            },
          ],
        },
      };
      
      // Convert object to XML
      const builder = new xml2js.Builder({
        rootName: 'document',
        headless: true,
        renderOpts: { pretty: true, indent: '  ' },
      });
      
      return builder.buildObject(xmlObj);
    } catch (error) {
      console.error('Error generating XML:', error);
      throw new Error('Failed to generate XML');
    }
  }
}

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { UsersModule } from './users/users.module';
import { ConversionsModule } from './conversions/conversions.module';
import { PdfModule } from './pdf/pdf.module';
import { XmlModule } from './xml/xml.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    PrismaModule,
    UsersModule,
    ConversionsModule,
    PdfModule,
    XmlModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'PDF to XML Converter API is running!';
  }
}

================
File: src/instrument.ts
================
// Import with `const Sentry = require("@sentry/nestjs");` if you are using CJS
import * as Sentry from "@sentry/nestjs"
import { nodeProfilingIntegration } from "@sentry/profiling-node";

Sentry.init({
  dsn: "https://badc0436683aa2a87b4255330a9ebf41@o4509085010821120.ingest.us.sentry.io/4509085414653952",
  integrations: [
    nodeProfilingIntegration(),
  ],
  // Tracing
  tracesSampleRate: 1.0, //  Capture 100% of the transactions
  // Set sampling rate for profiling - this is evaluated only once per SDK.init
  profileSessionSampleRate: 1.0,
});

// Manually call startProfiler and stopProfiler
// to profile the code in between
Sentry.profiler.startProfiler();

// Starts a transaction that will also be profiled
Sentry.startSpan({
  name: "My First Transaction",
}, () => {
  // the code executing inside the transaction will be wrapped in a span and profiled
});

// Calls to stopProfiler are optional - if you don't stop the profile session, it will keep profiling
// your application until the process exits or stopProfiler is called.
Sentry.profiler.stopProfiler();

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import * as Sentry from '@sentry/node';
import { ConfigService } from '@nestjs/config';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);
  
  // Setup Sentry for error tracking
  const sentryDsn = configService.get<string>('SENTRY_DSN');
  if (sentryDsn) {
    Sentry.init({
      dsn: sentryDsn,
      environment: configService.get<string>('NODE_ENV') || 'development',
    });
  }
  
  // Set up global validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
    }),
  );
  
  // Enable CORS
  app.enableCors();
  
  // Set up Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('PDF to XML Converter API')
    .setDescription('API for converting PDF files to XML')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);
  
  // Start the server
  const port = configService.get<number>('PORT', 3001);
  await app.listen(port);
  console.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: .env.example
================
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/pdf_to_xml?schema=public"

# Clerk Authentication
CLERK_SECRET_KEY=

# Sentry
SENTRY_DSN=

# App
PORT=3001
NODE_ENV=development

================
File: .gitignore
================
# Ignore build output
dist/
.cache/
.build/

# Ignore environment variables
.env
.env.local
.env.*.local

# Ignore TypeScript build files
*.tsbuildinfo

# Ignore logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: eslint.config.mjs
================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: package.json
================
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@clerk/clerk-sdk-node": "^5.1.6",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/swagger": "^11.1.0",
    "@prisma/client": "^6.5.0",
    "@sentry/nestjs": "^9.10.1",
    "@sentry/node": "^9.10.1",
    "@sentry/profiling-node": "^9.10.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "fast-xml-parser": "^5.0.9",
    "jsonwebtoken": "^9.0.2",
    "pdf-lib": "^1.17.1",
    "pdf-parse": "^1.1.1",
    "prisma": "^6.5.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.10.7",
    "@types/pdf-parse": "^1.1.4",
    "@types/supertest": "^6.0.2",
    "@types/xml2js": "^0.4.14",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}
